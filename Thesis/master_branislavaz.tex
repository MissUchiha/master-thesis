% Format teze zasnovan je na paketu memoir
% http://tug.ctan.org/macros/latex/contrib/memoir/memman.pdf ili
% http://texdoc.net/texmf-dist/doc/latex/memoir/memman.pdf
% 
% Prilikom zadavanja klase memoir, navedenim opcijama se podešava 
% veličina slova (12pt) i jednostrano štampanje (oneside).
% Ove parametre možete menjati samo ako pravite nezvanične verzije
% mastera za privatnu upotrebu (na primer, u b5 varijanti ima smisla 
% smanjiti 
\documentclass[12pt,oneside]{memoir}
% Paket koji definiše sve specifičnosti mastera Matematičkog fakulteta
\usepackage{matfmaster}
%
% Podrazumevano pismo je ćirilica.
%   Ako koristite pdflatex, a ne xetex, sav latinički tekst na srpskom jeziku
%   treba biti okružen sa \lat{...} ili \begin{latinica}...\end{latinica}.
%
% Opicija [latinica]:
%   ako želite da pišete latiniciom, dodajte opciju "latinica" tj.
%   prethodni paket uključite pomoću: \usepackage[latinica]{matfmaster}.
%   Ako koristite pdflatex, a ne xetex, sav ćirilički tekst treba biti
%   okružen sa \cir{...} ili \begin{cirilica}...\end{cirilica}.
%
% Opcija [biblatex]:
%   ako želite da koristite reference na više jezika i umesto paketa
%   bibtex da koristite BibLaTeX/Biber, dodajte opciju "biblatex" tj.
%   prethodni paket uključite pomoću: \usepackage[biblatex]{matfmaster}
%
% Opcija [b5paper]:
%   ako želite da napravite verziju teze u manjem (b5) formatu, navedite
%   opciju "b5paper", tj. prethodni paket uključite pomoću: 
%   \usepackage[b5paper]{matfmaster}. Tada ima smisla razmisliti o promeni
%   veličine slova (izmenom opcije 12pt na 11pt u \documentclass{memoir}).
%
% Naravno, opcije je moguće kombinovati.
% Npr. \usepackage[b5paper,biblatex]{matfmaster}

% Pomoćni paket koji generiše nasumičan tekst u kojem se javljaju sva slova
% azbuke (nema potrebe koristiti ovo u pravim disertacijama)
% Datoteka sa literaturom u BibTex tj. BibLaTeX/Biber formatu
\usepackage{multirow}
\usepackage{dcolumn}
\usepackage{amsthm}
\usepackage{tabularx}
\usepackage{ltablex} 
\usepackage{lscape}
\usepackage{booktabs}

\usepackage[unicode]{hyperref}
\hypersetup{colorlinks,citecolor=green,filecolor=green,linkcolor=blue,urlcolor=blue}

\newtheorem{definic}{Дефиниција}
\bib{master_branislavaz}

% Ime kandidata na srpskom jeziku (u odabranom pismu)
\autor{Бранислава Б. Живковић}
% Naslov teze na srpskom jeziku (u odabranom pismu)
\naslov{Паралелизација статичке верификације софтвера }
% Godina u kojoj je teza predana komisiji
\godina{2016}
% Ime i afilijacija mentora (u odabranom pismu)
\mentor{др Милена \textsc{Вујошевић Јаничић}, доцент\\ Универзитет у Београду, Математички факултет}
% Ime i afilijacija prvog člana komisije (u odabranom pismu)
\komisijaA{др Саша \textsc{Малков}, ванредни професор\\ Универзитет у Београду, Математички факултет}
% Ime i afilijacija drugog člana komisije (u odabranom pismu)
\komisijaB{др Филип \textsc{Марић}, ванредни професор\\ Универзитет у Београду, Математички факултет}
% Ime i afilijacija trećeg člana komisije (opciono)
% \komisijaC{}
% Ime i afilijacija četvrtog člana komisije (opciono)
% \komisijaD{}
% Datum odbrane (obrisati ili iskomentarisati narednu liniju ako datum odbrane nije poznat)
\datumodbrane{ 2016.}

% Apstrakt na srpskom jeziku (u odabranom pismu)
\apstr{%
}

% Ključne reči na srpskom jeziku (u odabranom pismu)
\kljucnereci{паралелизација, верификација, рачунарство}

\begin{document}
% ==============================================================================
% Uvodni deo teze
\frontmatter
% ==============================================================================
% Naslovna strana
\naslovna
% Strana sa podacima o mentoru i članovima komisije
\komisija
% Strana sa posvetom (u odabranom pismu)
\posveta{Брату, мами и тати}
% Strana sa podacima o disertaciji na srpskom jeziku
\apstrakt
\mainmatter
% Sadržaj teze
\tableofcontents

% ==============================================================================
% Glavni deo teze
% ==============================================================================

% ------------------------------------------------------------------------------
%\chapter{Увод}
% ------------------------------------------------------------------------------



\chapter{Увод} 
\subsection{Мотивација}
Испитивање задовољивости логичке формуле је НП-комплетан проблем и један је од најтежих проблема у рачунарству.


\chapter{Верификација}
	Верификација софтвера представља дисциплину рачунарства која се бави провером и доказивањем исправности програма. Програм је исправан уколико задовољава задату спецификацију, односно уколико за сваки улаз даје одговарајуће понашање предвиђено спецификацијом. Постоје два основна приступа верификацији \emph{динамичка} и \emph{статичка} верификација.
  \section{Динамичка верификација}
  Динамичка верификација програма се врши током његовог извршавања. Грешке у програму се покушавају пронаћи исцрпним тестирањем што је и циљ динамичке верификације. Битно је нагласити да тестирањем није могуће доказати исправност програма већ је могуће пронаћи грешке и на тај начин оповргнути претпоставку о исправности програма. 
  \\ \indent Да би се програм тестирао потребно је пронаћи одговарајући скуп улазних података помоћу којих се врши тестирање.  С обзиром на то да је простор могућих улаза углавном превелики, није могуће тестирати програм за све могуће улазе. Због тога треба издвојити одговарајући подскуп улазних података који што боље описује спецификацију програма и покрива што већи број случајева. Избор улазних података се углавном врши коришћењем програмског кода и спецификације. 
  \\ \indent Постоје две основне методе тестирања, метод \emph{црне} и 
 \emph{беле} кутије.  Методом црне кутије генерисање тестова се врши на основу спецификације програма не узимајући у обзир детаље имплементације. Методом беле кутије тестови се генеришу на основу кода и структуре програма. Такође, постоји и метод сиве кутије који представља мешавину ова два приступа. У зависности од тога шта је потребно тестирати бира/користи се одговарајући метод \cite{testing}. 
  
  
  \section{Статичка верификација}
  \label{statver}
  Статичка верификација програма представља испитивање исправности програма анализом програмског кода, без његовог извршавања. Анализа програмског кода се врши углавном над изворним или објектним кодом. Особине програма и услови исправности се описују одговарајућим формулама изабране математичке теорије. Изграђене формуле се даље анализирају коришћењем стриктних математичких метода. Неодлучивост халтинг проблема нам говори да није могуће испитати да ли је нека наредба програма достижна, па тиме ни да ли је програм потпуно исправан. Због тога се особине програма апроксимирају и описују одлучивим математичким теоријама. Аутоматизоване технике статичке анализе су \emph{проверавање модела}, \emph{апстрактна интерпретација} и \emph{симболичко извршавање}.  
  \\ 
Проверавање модела је техника верификације којом се испитује да ли модел система/програма задовољава одговарајућу спецификацију. Модел програма се описује коначним аутоматом који се састоји од стања и прелаза између стања, а спецификација се описује логичком формулом. Испитивање исправности програма се врши исцрпним и систематским обиласком стања аутомата како би се доказали услови задати спецификацијом. Уколико доказивање није могуће, генерише се одговарајући контрапример \cite{verif_tech}.
\\ 
Апстрактна интерпретација представља метод верификације код кога се семантика програма апроксимира математичким моделом. Понашање програма се описује одговарајућим апстрактним доменом и релацијама над њиме. Анализом апстрактног домена могуће је добити информације о резултатима рада програма без његовог извршавања \cite{verif_tech}. 
\\ 
Симболичко извршавање је метод верификације који анализира понашање програма на основу симболичких вредности променљивих. Путање програма се описују симболичким изразима а испитивање исправности програма се врши анализом конструисаних израза. Резултати анализе неке путање програма важе за све могуће улазне вредности променњивих које прате дату путању \cite{symbolic_exec}.

  \section{Алати за верификацију}
У наставку ће бити описани неки верификациони алати који користе поменуте технике приликом испитивања исправности програма. 

\paragraph{ LLBMC (енг. Low-Level Bounded Model Checker)} је алат који проверава исправност 
C и C++ програма. Користи технике за проверавање ограничених модела над LLVM међукодом. Проналази грешке дељења нулом, прекорачење бафера, неисправног и двоструког ослобађања меморије, прекорачења у аритметичким изразима и проверава кориснички задате услове. За проверавање услова исправности користи SMT решаваче STP i Boolector \cite{llbmc}.

\paragraph{PAGAI} је верификациони алат отвореног кода који ради над LLVM инфраструктуром. Имплементира технике апстрактне интерпретације и  генеришући аутоматски инваријанте петљи које касније уписује у анализирани код.  Такође може да проверава кориснички задате услове кроз макрое претпоставки (енг. assertion macro) \cite{pagai}.

\paragraph{KLEE} је алат који врши симболичко извршавање и генерисање тест примера над програмима који су писани у језику C. Настао је на Универзитету Илиноис и јавно је доступан. KLEE анализира LLVM међукод користећи SMT решавач STP приликом испитивања услова исправности \cite{klee}. 

\paragraph{CBMC} је алат за верификацију C и C++ програма првенствено намењен за верификацију уграђених система (енг. embedded systems). CBMC врши симболичко израчунавање тако што изворни код програма претаче у SMT формулу и испитује њену задовољивост \cite{cbmc}. 

  \section{ЛАВ}
	ЛАВ је алат за статичку верификацију софтвера \cite{mvjphd}. Oтвореног је кода и доступан је на адреси \url{http://argo.matf.bg.ac.rs/?content=lav}. 
  \\
	ЛАВ имплементира статичку анализу, генерисање и испитивање услова исправности императивних програма комбинујући методе описане у поглављу \ref{statver}. Користи LLVM инфраструктуру ради трансформације програма у форму која је погодна за анализу и првенствено је намењен за анализу програма написаних у програмском језику C. Међутим, универзалност LLVM платформе омогућава и анализу других процедуралних језика који се могу компајлирати у LLVM код, као што су језици C++, Ada и Fortran. ЛАВ моделује понашање програма и генерише услове исправности трансформишући их у формуле одговарајуће теорије логике првог реда. Теорије које су подржане су аритметика бит-вектора, линеарна аритметика, теорија неинтерпретираних функција (или акерменизација) и теорија низова.  Симболичким извршавањем ЛАВ генерише формуле изабране теорије логике првог реда које описују понашање сваког блока LLVM међукода као и њихове релације. 
	\\
	ЛАВ генерише формуле исправности неке наредбе и испитује њихову задовољивост користећи SMT решавач. Комбинацијом ових формула граде се формуле које описују понашање програма. 
	\\
	 Формуле се конструишу по потреби у различитим контекстима. Контекст дефинише информације из околине наредбе које ће бити узете у разматрање приликом расуђивања о наредби. Контексти који постоје су празан контекст, контекст блока, контекст функције и контекст у коме је функција позвана. Разликују се по ширини од најужег до најширег. Приликом испитивања исправности наредбе почиње се са празним контекстом.  Након генерисања формуле у оквиру једног контекста, формула се шаље SMT решавачу на проверу. У зависности од резултата испитују се и шири контексти. 
\\	
 На основу резултата решавача ЛАВ генерише извештај о безбедности наредби програма \cite{mvjdev}. 	
	 
	
\chapter{Паралелизација}
	Термини паралелизам и конкурентност у рачунарству су углавном испреплетани и погрешно схваћени. Често се грешком поистовећују и сматрају синонимима иако то нису. Због тога је битно да их правилно дефинишемо и разликујемо \cite{par_computing}.
\begin{definic}
	Конкурентност је својство програма које се односи на то да два или више задатака могу бити истовремено у току. (исправити превод)
\end{definic}
\begin{definic}
	Паралелизам је својство програма да извршава два или више задатака истовремено. (исправити превод)
\end{definic}

Битно је напоменути да постоји разлика у томе да ли се два задатка истовремено извршавају или су истовремено у току. Наиме, паралелизам изискује/захтева конкурентност, док обрнуто не важи. Може се рећи да је конкурентност начин структуирања програма а паралелизам начин извршавања програма. Конкурентни програми се могу извршавати паралелно али не морају. Паралелизам захтева архитектуру која има више процесорских јединица, док се конкурентност може остварити и на једном процесору.
	\\
 \indent 	Паралелно програмирање је област рачунарства која се бави архитектуром система и софтверским проблемима програма са паралелним извршавањем. Програм се може дефинисати као низ наредби које се извршавају након његовог покретања. Секвенцијалне програме одликује серијско извршавање наредби. Паралелизам је карактеристика програма која се односи на независност његових израчунавања. Независна израчунавања се могу истовремено односно паралелно извршавати на више процесорских јединица.
  \section{Мотивација}
  Интересовање за паралелизацију се јавља касних 1950-их са зачетком теоријских основа док се први технички напредак осећа почетком 1960-их и и даље се развија/расте. Први суперрачунари су се појавили 60-их година и имали су више процесора који су могли паралелно да раде са дељеном меморијом. Даљим развојем 80-их година се појављују кластери, системи који се састоје од великог броја рачунара тзв. чворова међусобно повезаних преко мреже. 90-их година са експанзијом интернета се појављује рачунарство у облаку, док данас већина кућних рачунара садржи процесоре са више језгара. \\
  \indent Може се рећи да перформансе рачунара експоненцијално расту од 1945 године за фактор 10 сваких 5 година. Први рачунари су израчунавали десетине операција са бројевима у покретном зарезу у секунди, паралелни рачунари 1990-их достижу број од пар десетина милијарди операција у секунди. Рачунарске/софтверске архитектуре су морале да испрате овакав нагли раст што се постиже преласком са секвенцијалног на паралелно програмирање \cite{par_history}.
  \\
 \indent Перформансе софтверских решења зависе од времена извршавања основних операција, попут операција са бројевима у покретном зарезу, као и од броја оваквих операција које се могу извршавати паралелно. С обзиром на то да ово време зависи од брзине откуцаја часовника процесора која полако тежи ка теоријском максимуму (брзина светлости) не можемо се ослонити на то да ће бржи процесори подићи перформансе нумеричких израчунавања. Главна мотивација и циљ паралелног програмирања је подизање перформанси рачунарских система односно убрзање програма. Потреба за паралелним приступом расте и због тога што је секвенцијалним приступом решавање многих комплексних проблема временски захтевно. 
 \\
\indent \emph{Убрзање паралелизацијом} је мера која показује колико пута паралелни програми брже решавају исте проблеме него секвенцијални програми. Формула убрзања је следећа \cite{par_various}:
 	$$ S = T_s/T_p $$
 	
\noindent где $ T_s $ представља време извршавања секвенцијаног а $ T_p $ време извршавања паралелног програма за исти проблем. 
 	\\
 	\indent По Амдаловом закону, извршавање паралелног програма на паралелном рачунару углавном обухвата и део операција које се не могу извршавати паралелно. Означимо са $ \alpha $ део програма који се мора извршавати секвенцијално на једном процесору, а остатак $ (1 - \alpha)$ се може извршити паралелно. Ако је $ N $ број процесорских јединица, формула убрзања је: 
 	$$ S = 1 / ( \alpha + (1-\alpha)/N)$$
Ова формула нам показује да убрзање никада не може прећи $ 1/\alpha $, тј. број процесорских јединица не утиче на део програма који се мора извршавати секвенцијално. На слици \ref{fig:amdal} је приказана зависност убрзања од броја процесора и дела посла који се мора обавити секвенцијално.

 \begin{figure}[!ht]
  \centering
  \includegraphics[width=0.8\textwidth]{amdal.png}
  \caption{Зависност убрзања од броја процесора за неке вредности $ \alpha $ }
  \label{fig:amdal}
\end{figure}


 \indent У пракси, време извршавања програма на паралелним системима је углавном веће од теоријски израчунате вредности јер зависи и од других параметара попут комуникације и синхронизације. Амдалов модел не узима у обзир ова времена и разматра само случајеве у којима је димензија проблема фиксирана. Поред Амдаловог модела постоје и други модели као што су Густафсонов, Гинтеров, модел Сун Ни-ја који превазилазе нека ограничења Амдаловог модела \cite{performance}.
 	 


  \section{Врсте паралелизације}
  
 Програми се могу паралелизовати на различите начине. Паралилзацију може обављати програмер експлицитно или коришћењем неких алата. Последњих година развијени су многи алати који омогућују аутоматску паралелизацију. Коришћењем ових алата програмеру је олакшан процес паралелизације уз ограничену контролу. Овакав начин паралелизације је погодан за велике и комплексне системе код којих би ручна паралелизација била спора и компликована.
 \\
 \indent Са друге стране, ручна паралелизација програма захтева добро обучене програмере и углавном је сложенија али пружа програмерима потпуну контролу над самим процесом паралелизације. Овакав приступ је погоднији за паралелизацију специфичних проблема.
 \\
  \indent  Битно је нагласити да није могуће паралелизовати све делове сваког алгоритма. Посао програмера је да пронађе и одлучи који делови алгоритма се могу паралелизовати и на који начин.
 Два најчешћа приступа дизајнирању паралелних алгоритама су \emph{паралелизација задатака} и \emph{паралелизација података}. 
Паралелизација задатака представља раслојавање алгоритма на независне задатке који се могу извршавати било којим редоследом над истим скупом података.
Паралелизација података представља раслојавање података тако да се један задатак може независно извршавати над дисјунктним деловима података било којим редоследом \cite{art_conc}. 
На слици  \ref{fig:data_parallel} је приказан пример паралелизације задатака а на слици \ref{fig:task_parallel} пример паралелизације података

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.6\textwidth]{data_parallel.png}
  \caption{Пример паралелизације података: примена функције capslock над сваким словом појединачно}
  \label{fig:data_parallel}
\end{figure}

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.6\textwidth]{task_parallel.png}
  \caption{Пример паралелизације задатака: примена различитих функција над свим подацима}
  \label{fig:task_parallel}
\end{figure}


  \section{Проблеми}
  Често није могуће раслојити алгоритам на потпуно независне задатке који се могу паралелно извршавати већ је присутан одређен ниво зависности између њих. На пример, уколико задаци могу приступити истој променљивој у програму и променити њену вредност, потенцијално више задатака може истовремено покушати да је измени. У таквим ситуацијама задаци се надмећу за приступ дењеним подацима.  Овакви и овоме слични проблеми индукују постојање \emph{критичне секције}. Критична секција представља низ наредби који мора задовољавати следећи услов: уколико је један задатак ушао у критичну секцију и почео да је извршава, ниједан други задатак је не сме извршавати истовремено. У складу са тиме постоје бројна решења и механизми који омогућавају \emph{комуникацију} и  \emph{синхронизацију} између задатака.
\\ 
 \indent  
Комуникација представља било који вид размене информација између задатака. Може се остварити преко дељене меморије или слањем односно примањем порука. Комуникација преко порука се одвија тако што један задатак експлицитно шаље податке другом задатку који их прихвата и обрађује. Неки од познатих механизама за овакав вид комуникације су сигнали, цеви, сокети и канали.
Постојање дељене меморије има своје добре и лоше стране. Понекад је потребно старати се о редоследу читања односно писања дељене меморије као и о евентуалним утркивањима и сукобима. Због тога комуникација преко дељене меморије може захтевати одређен ниво синхронизације. Кроз механизме синхронизације програмер може контролисати редослед извршавања задатака и приступ дељеној меморији. Две основне врсте овакве синхронизације су \emph{сарадња} и \emph{такмичење}. Синхронизација сарадње између два задатка је потребна уколико један задатак зависи од резултата рада другог. Синхронизација такмичења је неоходна у случајевима када два задатка истовремено захтевају исти ресурс. Механизми који се користе за имплементацију синхронизације су мутекси, катанци, семафори, монитори и други \cite{lang_prag}.
\\ \indent Синхронизација отвара многе проблеме, нпр. могућност \emph{узајамног блокирања}, \emph{живог блокирања} и \emph{изгладњивања} између задатака. Ови проблеми се односе на концепт \emph{напредовања} (енг. liveness) програма. Концепт напредовања програма представља својство програма да у току свог извршавања напредује доводећи до предвиђеног догађаја у неком тренутку, односно да константно прави прогрес током свог извршавања. Уколико ово својство није задовољено може да се деси да програм не може да настави са својим извршавањем. Узајамно блокирање (енг. deadlock) се дешава у ситуацији када два задатка чекају један на другог како би наставили са радом и на тај начин губе напредак. Живо блокирање (енг. livelock) представља ситуацију када сви задаци раде али нема напретка. Изгладњивање се односи на могућност да један задатак спречава извршавање другог. Поменути проблеми се могу спречити одговарајућим алгоритмима \cite{opsis}.


 % \section{Неки патерни}
  \section{Алати за паралелизацију}
	У овом поглављу ће бити описане неке библиотеке које се користе за паралелизацију програмског кода. Акценат ће бити на библиотекама за језик Ц++. 
	\\ \indent Алате можемо поделити у две категорије имплицитне и експлицитне. Имплицитни алати олакшавају програмеру имплементацију паралелних алгоритама јер се старају о прављењу, управљању и синхронизацији нити. Експлицитни алати пружају већу флексибилности и контролу захтевајући од програмера да управља свим аспектима вишенитности.
	
\paragraph{ PThreads (енг. POSIX Threading interface)} је интерфејс за паралелно програмирање на нивоу оперативног система и доступан је у оквиру већине UNIX-оликих оперативних система. Имплементиран је у оквиру заглавља \\ \texttt{pthread.h} језика Ц који садржи скуп константи, типова и функција за паралелизацију. Програмеру је омогућено прављење нити и управљање њиховим извршавањем. Комуникација се обавља преко дељене меморије коју такође програмер контролише. Дељена меморија се имплементира коришћењем глобалних променљивих које су видљиве свим нитима. Садржај заглавља \texttt{pthread.h} уз одговарајућу документацију се може наћи на адреси \url{http://man7.org/linux/man-pages/man7/pthreads.7.html}.

\paragraph{OpenMP (енг. Open Specification for Multi-Processing)} је интерфејс за програмирање који омогућава паралелно програмирање у језицима C++, C++ и Фортран . Заснива се на моделу паралелизације коришћењем дељене меморије. Садржи скуп компајлерских директива, рутина и глобалних променљивих које служе за обележавање делова програмског кода. Програм се дели на регионе који се извршавају серијски и регионе који се извршавају паралелно. Региони се означавају директивама које управљају процесом додељивања задатака нитима, комуникацијом и синхронизацијом. Променљиве могу бити дељене, односно видљиве свим нитима, и приватне, односно видљиве у оквиру нити унутар које су декларисане. Детаљна документација се може наћи на адреси \url{http://www.openmp.org}. 

\paragraph{TBB (енг. Thread Building Blocks)} је C++ библиотека за паралелно програмирање на вишепроцесорским системима развијена од стране \emph{Intel}-а. Библиотека се састоји од бројних шаблона који имплементирају паралелне алгоритме, контејнере, примитиве за синхронизацију и управљач задацима. Програмери дефинишу задатке који ће се извршавати паралелно након чега се управљач задацима стара о току извршавања и техничким детаљима. Више о овој библиотеци се може наћи на адреси \url{http://www.threadingbuildingblocks.org}.


  
\chapter{Имплементација}

Mодул који се бави паралелизацијом је развијен у складу са специфичним захтевима система ЛАВ. Систем ЛАВ је сложен верификациони алат писан у C++ језику. Као такав користи многе спољне библиотеке, алате, као и СМТ решаваче.  Архитектура самог система је модуларна, функционалне целине су издвојене у посебне модуле и по потреби увезиване и коришћене. Модул за паралелизацију представља посебну издвојену целину тако да се може универзално користити у различитим деловима система. Имплементиран је коришћењем  и комбинацијом различитих библиотека језика C++.   У наставку текста ће бити описана архитекура и имплементација модула за паралелизацију као и начини његовог коришћења у оквиру система ЛАВ. Изворни код се може пронаћи на адреси \url{https://github.com/milenavj/LAV} (директоријуми \texttt{include/lav/Threads} и \texttt{lib/Threads}) а интеграција са ЛАВ-ом се налази унутар класа \texttt{LBlock}, \texttt{LModule} и \texttt{LState}.  

\section{Опис проблема}
Процес верификације у систему ЛАВ је имплементиран секвенцијално. На улазу се задаје модул (скуп датотека) који је потребно анализирати.  ЛАВ разлаже модул на његове функције и почев од \texttt{main} функције (име почетне функције може да се зада) прави граф позива функција  на основу кога се функције верификују. Даље, функције се разлажу на блокове, а блокови на појединачне наредбе. Симболичким извршавањем конструише се SMT формула која описује услов исправности неке потенцијално небезбедне наредбе. SMT решавачу се на проверу шаље негација ове формуле и уколико је она незадовољива, онда то значи да је употреба одговарајуће наредбе исправна. Уколико се за потенцијално небезбедне наредбе једног блока покаже да су исправне, онда то значи да је анализирани блок исправан. Уколико су сви блокови унутар једне функције исправни, онда је и сама функција исправна. Слично важи и за модул. 
\\
Као што знамо, програми могу бити комплексни, са великим бројем функцијa (блокова и наредби), због чега и овај процес може бити дуг и исцрпан. Додатно, функције често позивају једна другу и међусобно су зависне. Због тога, неретко се догађа да функција А позива функцију Б, функција Б позива функцију Ц, док је функција Д неисправна али њена верификација се може обавити тек након што се заврши верификација функција А, Б и Ц. Ова и сличне ситуације су биле мотивација за паралелизацију процеса верификације. Паралелизација је имплементирана на два нивоа. Први ниво је паралелно верификовање различитих наредби у оквиру једног блока, а други ниво је паралелно верификовање самих функција.

Систем ЛАВ имплементира алгоритам који услове исправности програма описује формулама изабране логике првог реда и испитује њихову задовољивост.  Испитивање задовољивости је  временски веома захтевно и може да варира у зависности од формуле. ЛАВ редом шаље формуле SMT решавачу након чега чека његов одговор. Имајући у виду разноврсност формула могуће је да испитивање првих неколико формула траје кратко, затим да испитивање наредне формуле траје доста дуже, након чега следе формуле чије испитивање поново траје кратко. Тешка формула у оваквој ситуацији блокира цео систем све док се не разреши. Ово може бити значајно успорење система, посебно уколико нека од формула која следи након тешке формуле показује да је наредба, чију исправност испитујемо, неисправна. 	
Како би се избегле овакве ситуације идеја је да се паралелизује овај процес коршћењем могућности вишепроцесорског хардвера. Циљ овог рада је имплементација паралелизације процеса испитивања задовољивости формула које се генеришу у оквиру контекста блока једне наредбе. 

\section{Опис архитектуре}

Архитектура модула за паралелизацију је осмишљена тако да испуњава захтеве система ЛАВ. Модул за паралелизацију има три основна дела: контролни део, радне нити и комуникациони део. Улога контролног дела је да управља радним нитима, ослушкује и прихвата сигнале тј. догађаје које емитују радне нити и обрађује 	њихове резултате. Радне нити извршавају задатке и обавештавају контролни део о резултатима. Део који се бави комуникацијом омогућава комуникацију између контролног дела и радних нити. Композицијом ових делова имплементиран је модул који паралелизује неке делове алгоритма анализе програмског кода у овиру система ЛАВ.
\newpage

\section{Имплементација модула}
За имплементацију модула коришћен је језик C++ због компатибилности са системом ЛАВ. Приликом имплементације појединачних нити коришћен је модел нити из библиотеке \texttt{<thread>} језика C++. Ова библиотека је јавно доступнa и нуди интерфејс (енг. application programming interface, API) за конструкцију и управљање нитима.
\\ \indent 
Класа \texttt{ThreadPool} представља контролни део модула, тзв. базен нити. Она садржи контролну нит чија је улога контрола радних нити које се такође налазе у оквиру ове класе (\texttt{ThreadPool}). Посао радних нити је да извршавају задатке који су прослеђени базену нити. Због тога се унутар базена нити чува и ред задатака (класа \texttt{FixedQueue}) које је потребно извршити. Класа \texttt{FixedQueue} је шаблонска класа и може садржати ред објеката било ког типа. Задаци који се смештају у ред су објекати C++ апстракције анонимних (ламбда) функција, и због специфичности проблема имају следећи потпис: \texttt{int f()}. Наравно, потпис ових функција се може уопштити, али за потребе овог рада то није било неопходно. 

 Задатке извршавају радне нити, објекти класе \texttt{std::thread}, које су обмотане класом \texttt{SignalingThread}.
Базен нити садржи објекат реда \texttt{FixedQueue} као и низ радних нити. Могуће је задати број нити али уколико другачије није наглашено конструисаће се онолико радних нити колико оперативни систем дозвољава.

Свакој радној нити се приликом иницијализације прослеђује дељени показивач (\texttt{std::shared\_ptr}) на ред задатака, тако да све нити имају приступ истом објекту реда. Нити скидају са реда један по један задатак и извршавају га. Како све нити приступају истом објекту реда, потребно је синхронизовати процес скидања задатака. C++ језик, у оквиру библиотеке \texttt{<atomic>} нуди разне типове над којим су подржане атомичне операције. Све операције над овим типовима су безбедне у контексту вишенитног окружења. Класа \texttt{FixedQueue} садржи јединствен показивач на објекат атомичног типа (\texttt{std::unique\_ptr<std::atomic\_uint>}). Овај објекат чува информацију о томе колико је задатака скинуто са реда (индекс следећег задатка који треба скинути). Радне нити могу затражити задатак из реда, и уколико две или више нити у исто време покушају скинути задатак са реда, свака ће добити различит задатак, тако да се приликом испоруке задатака гарантује да ће све нити добити различите задатке.  На овај начин је избегнуто утркивање нити као и синхронизација коришћењем традиционалних метода (мутекси, закључавање, и др). 

Након што изврши задатак, нит обавештава базен нити емитовањем догађаја, објекат класе  \texttt{Event}. Свака нит садржи посебан објекат догађаја тако да се базен нити претплаћује на ослшкивање догађаја сваке нити посебно. Резултат извршавања задатака нити обрађују и шаљу сигнал базену нити емитовањем одговарајућег догађаја. Контролна нит која се налази у базену нити тумачи сигнал и предузима потребне акције. 

Због специфичних потреба приликом паралелне анализе функција, направљена је и класа \texttt{FutureResult} која чува статус верификације једне функције. Ова класа је имплементирана коришћењем асинхроних механизама \texttt{std::future} и \texttt{std::promise} из библиотеке \texttt{<future>}\footnote{Више о овој библиотеци можете пронаћи на страници \url{//www.cplusplus.com/reference/future}}.	

Дијаграм класа се налази на слици \ref{fig:klasa_dij}.
 
 
 \begin{figure}[!ht]
  \centering
  \includegraphics[width=1.0\textwidth]{class_diag.png}
  \caption{Дијаграм класа}
  \label{fig:klasa_dij}
\end{figure}


\section{Интеграција модула са системом ЛАВ}

Паралелизација је имплементирана у контексту анализе наредби и функција модула који се верификује. 

\subsection{Паралелна анализа наредби}

Класа \texttt{LBlock} система ЛАВ служи за рад са блоковима кода. Њена функција \texttt{CalculateConditions} конструише формуле које представљају услове исправности блока и позивају SMT решавач за сваку формулу. Модул за паралелизацију омогућава да се ови позиви решавача извршавају паралелно.

 За сваку формулу, услов исправности, унутар функције \texttt{CalculateConditions} конструише се функција која позива SMT решавач. Функција као резултат враћа индикатор да ли је услов исправности испуњен или не. Направљене функције се смештају у ред \texttt{FixedQueue} и прослеђују инстанци класе \texttt{ThreadPool} (базен нити). Базен нити прави радне нити и покреће их. Свака нит извршава једну по једну функцију, скидајући их са реда и обавештава базен нити о резултату извршавања. Уколико се наиђе на услов исправности који није задовољен, нема потребе испитивати остале услове јер се тада блок сматра неисправним. У контексту имплементације то значи да уколико нека функција врати индикатор да услов исправности није испуњен, нити могу престати са радом јер се задат блок означава као неисправан. Ако је приликом покретања система ЛАВ (била) задата опција \texttt{-find-first-flawed} користи се понашање које је описано - прекидање у случају наиласка на неисправну наредбу. Ако та опција није присутна, онда се редом све испитује. Када све функције из реда заврше тако да су сви услови су били задовољени, блок се сматра исправним и тако бива означен. 
 
 На слици \ref{fig:sekv_dij}  је приказан један могући сценарио. На почетку се врши конструкција и иницијализација свих потребних објеката. Базен нити конструише три радне нити које узимају задатке са реда. Нити  \texttt{SignalingThread1} прва узима задатак са реда, а након ње и \texttt{SignalingThread2} и обе почињу да их извршавају. Нит \texttt{SignalingThread1} прва завршава успешно, пре него што је нит \texttt{SignalingThread3} узела задатак са реда. Након тога обе нити,  \texttt{SignalingThread1} и  \texttt{SignalingThread3} покушају узети следећи задатак. Имајући у виду то да један ред задатака деле све нити, овај процес узимања задатака ће се извршити секвенцијално (користећи погодне функције из библиотеке  \texttt{<atomic>}) тако да нит \texttt{SignalingThread1} прва добија задатак са реда. Како нит  \texttt{SignalingThread1} наилази на услов исправности који није испуњен, шаље сигнал базену нити након чега остале нити бивају заустављене и систем ЛАВ бива обавештен о неисправном резултату. Можемо приметити да је редослед акција прављења нити, узимање задатака са реда и брзина извршавања задатака у овом примеру конкретизован. Наравно, у општем случају тај редослед је произвољан и зависи од много фактора као што су специфичности оперативног система, сложеност задатака, број задатака у реду, и слично.  

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.8\textwidth]{seq_diag.png}
  \caption{Дијаграм тока извршавања}
  \label{fig:sekv_dij}
\end{figure}

\subsection{Паралелна анализа функција}

Анализа функција је имплементирана користећи исте механизме уз мале додатке због различитости проблема.   
 Класа \texttt{LModule} је одговорна за анализу функција једног модула. Функције могу зависити једне од других због чега је потребно чувати информације о резултату верификације сваке функције појединачно. Верификација модула почиње позивом метода \texttt{Run} класе \texttt{LModule} у оквиру кога се конструишу нити које анализирају функције тог модула. Класи \texttt{LModule} је додат низ објеката \texttt{FutureResult} за сваку функцију тог модула. Класа \texttt{FutureResult} представља структуру података унутар које се чува податак о завршетку верификације неке функције. Ова класа садржи објекат класе \texttt{std::promise}  који чува вредност (информацију о завршетку верификације) и објекат \texttt{std::future} помоћу кога нити приступају тој вредности. Свака нит има дељени показивач на низ објеката \texttt{FutureResult} тако да у сваком тренутку може погледати резултат верификације неке друге функције. Уколико се верификација тражене функције није завршила, тренутна нит ће сачекати на њен резултат позивом функције \texttt{wait} над објектом \texttt{std::future} за ту функцију. Када се верификација тражене функције заврши, резултат ће се уписати у њен објекат \texttt{std::promise} и функција \texttt{wait} ће завршити са чекањем. Наиласком на неисправну функцију, верификација се завршава, програм се означава неисправним, а остале нити се отказују. 

\chapter{Експериментални резултати}

У наставку текста ће бити приказани резултати поређења модификованог система ЛАВ са алатом CBMC. 
  \section{Архитектура рачунара}
  
  С обзиром на то да се рад заснива на паралелној импмементацији, експерименти су покретани на кластер рачунару са четрдесет процесорских језгара и Ubuntu 16.04 оперативним системом. Максимално време извршавања програма је поставњено на пет минута и мерено је системским програмом \texttt{time}.
  
  \section{Опис корпуса}
  
  Експерименти су покретани на два корпуса, први демонстрира побољшање услед паралелне верификације блокова, а други демонстрира побољшање услед паралелне верификације функција програма.
  \subsection{Први корпус}
  
  Корпус садржи двадесет програма писаних у програмском језику C. Програми су генерисани повећавањем броја валидних наредби које претходе невалидној наредби у блоку и именовани на основу тог броја. Велики број наредби повлачи велике SMT формуле чиме се повећава комплексност проблема. 	Први програм изгледа овако:
  \\
  
\begin{verbatim}

int m(int a, int b, int c, int d)
{

	a = (b<<3)*((c>>2)/3);
	b = (a<<3)*((c>>2)/3);
	c = (b<<3)*((a>>2)/3);
	a = (b<<3)*((c>>2)/3);
	b = (a<<3)*((c>>2)/3);
	c = (b<<3)*((a>>2)/3);
	a = (b<<3)*((c>>2)/3);
	b = (a<<3)*((c>>2)/3);
	c = (b<<3)*((a>>2)/3);
	a = (b<<3)*((c>>2)/3);
	b = (a<<3)*((c>>2)/3);
	c = (b<<3)*((a>>2)/3);

	// problematicne naredbe
	
	a = b/c + b/a + c/(++b);

	b = a/d;
	
	return b;
}

\end{verbatim}   

Сви наредни програми у корпусу су конструисани на основу наведеног додавањем истих наредби пре проблематичне наредбе. Програми су преведени у 32b и 64b формат.	  
  \subsection{Други корпус}

\newpage
    
  \section{Начини покретања}
ЛАВ је покретан са опцијом заустављања приликом наиласка на прву невалидну наредбу, решавач који је коришћен је Z3. CBMC је покретан са параметром који испитује проблем дељења нулом. Број нити није експлицитно задат. \footnote{То је број који је добијен као препорука оперативног система и не мора представљати број физичких језгара на рачунару.}

 
  \section{Измерена времена}
  
  Добијени резултати се налазе у табели \ref{eksp_blok}, измерена времена су приказана у секундама. \\
  
\begin{table}
  \begin{tabularx}{1\textwidth}{|>{\setlength\hsize{1\hsize}\centering}X|>{\setlength\hsize{1\hsize}\centering}X|>{\setlength\hsize{1\hsize}\centering}X|>{\setlength\hsize{1\hsize}\centering}X|X|}
  \hline
  	\multirow{2}{*}{број линија} & \multicolumn{2}{ |c }{32b} &\multicolumn{2}{ | c | }{64b} 
	\\
	\cline{2-5}
	& LAV & CBMC & LAV & \hspace{15px} CBMC \\	
	\cline{1-5}
	12 & 0.08 & 0.81 & 0.06 & \hspace{20px} 0.81 \\	
  \cline{1-5}
	13 & 0.08 & 0.80 & 0.07 & \hspace{20px} 0.79 \\	
  \cline{1-5}
	14 & 0.08 & 0.64 & 0.07 & \hspace{20px} 0.93 \\	
  \cline{1-5}
	15 & 0.08 & 0.99 & 0.56 & \hspace{20px} 1.16 \\	
  \cline{1-5}
	16 & 0.51 & 1.17 & 0.12 & \hspace{20px} 1.49 \\	
  \cline{1-5}
	17 & 0.51 & 1.34 & 0.59 & \hspace{20px} 2.10 \\	
  \cline{1-5}
	18 & 0.09 & 2.44 & 0.10 & \hspace{20px} 3.15 \\	
  \cline{1-5}
	19 & 0.09 & 3.16 & 0.10 & \hspace{20px} 4.31 \\	
  \cline{1-5}
	20 & 0.11 & 4.06 & 0.56 & \hspace{20px} 8.13 \\	
  \cline{1-5}
	21 & 0.10 & 18.63 & 0.11 & \hspace{20px} 12.11 \\	
  \cline{1-5}
	22 & 0.54 & 27.20 & 0.10 & \hspace{20px} 17.37 \\	
  \cline{1-5}
	23 & 0.11 & 22.56 & 0.12 & \hspace{20px} 34.85 \\	
  \cline{1-5}
	24 & 0.11 & 48.25 & 0.11 & \hspace{20px} 53.56 \\	
  \cline{1-5}
	25 & 0.12 & 79.45 & 0.13 & \hspace{20px} 76.11 \\	
   \cline{1-5}
	26 & 0.14 & 108.93 & 0.10 & \hspace{20px} 148.99 \\	
   \cline{1-5}
	27 & 0.13 & 215.31 & 0.14 & \hspace{20px} 230.77 \\	
   \cline{1-5}
	28 & 0.17 & 300+ & 0.15 & \hspace{20px} 300+ \\	
   \cline{1-5}
	29 & 0.13 & 300+ & 0.14 & \hspace{20px} 300+ \\	
   \cline{1-5}
	30 & 0.13 & 300+ & 0.15 & \hspace{20px} 300+ \\	
   \cline{1-5}
	60 & 0.23 & 300+ & 0.20 & \hspace{20px} 300+ \\	
   \cline{1-5}
  \end{tabularx}

\caption[]{Експериментални резултати алата ЛАВ и CBMC на првом корпусу {\label{eksp_blok}}}
\end{table}
  
 \section{Објашњавање експерименталних резултата}

\literatura
% ==============================================================================
% Završni deo teze i prilozi
\backmatter
\end{document} 
